%%%% Time-stamp: <2012-08-20 17:41:39 vk>

%% example text content
%% scrartcl and scrreprt starts with section, subsection, subsubsection, ...
%% scrbook starts with part (optional), chapter, section, ...
\chapter{Software Development Techniques}
\label{sec:SDT}

When it comes to software engineering one of the most important questions is which software development process 
is the best fit for the particular project requirements. There is a high variety of possible strategies, whereby 
each strategy has its own strengths and weaknesses depending on their field of application. Therefore no universal 
all in one solution exists which fits no matter the concerning circumstances. This means some preparation and 
organizational work inside the software team has to be accomplished beforehand. The production of the right software 
has to factor in the experience of the software developers, the team size as well as considering the needs and wishes 
of other stakeholders. It is important to find the most appropriate methodology to satisfy all parties included.

Basically software projects can be divided into phases, so called life cycles. The most common life cycles are 
requirements analysis and definition, software design, implementation, verification and maintenance. Taking those 
phases into account a division into two groups evolved: traditional and agile approaches.

Traditional approaches typically execute the phases sequentially, meaning that one phase does not get processed if 
its predecessor has not been completed. The waterfall model is considered to be a well-known representative for a traditional approach.

% WATERFALL Image

On the contrary agile approaches are based on iterative and incremental development, which means that the life cycles 
get passed through several times. Thus agile approaches more often result in intermediate software releases which 
encourage adaptations even late in the project’s development phase. Extreme programming is just one of many realisations 
of agile software development methodologies. Since key aspects of its definition are used in the implementation of the OBD 
software its background as well as its approach are covered in this section. 

The following sections layout the the reasons for choosing a particular software development technique instead of deciding 
for another. In addition to that the basics will be explained in particular together with our approach and a final summarization 
containing our experiences and knowledge we gathered by practicing those methodologies over the course of the bachelor thesis.

\section{Basics}

The motivation to apply the extreme programming methodology is based on the already gathered know-how in this field by attending 
and finishing the course “Softwareentwicklung und Wissensmanagement” in a prior semester. Additionally, taking into consideration 
that the software is designed to be used in an automotive context, the Automotive SPICE standard, which is derived from the ISO 15504, 
has to be combined with the test-driven development aspect of extreme programming.

Last but not least prioritizing a consistent coding style within the project to keep the source code itself as well as the overall 
structure as clear as possible is intended. Thus simplifying future maintenance and refactoring for programmers who are not implicitly 
the initial developers of the source code. Furthermore this goal is pursue this by basically agreeing to an internal coding standard 
based on the book “Clean Code: A Handbook of Agile Software Craftsmanship 1st Edition” by Robert C. Martin.

\subsection{Extreme Programming}

As mentioned in the previous chapter the extreme programming attempt is a type of agile software development. Generally it is designed 
to enable small teams to develop software whose requirements change frequently due to their ambiguous definition. Furthermore it is meant 
to be a test-driven development approach. In other words a central point of extreme programming is to write unit tests before any “real” 
code is written. Thus securing the passing of newly written tests as well as already implemented ones is very important. Rather than 
focussing on testing each unit separately, extreme programming also requires to test the whole system, in the best case, several times a day.

Best practice in extreme programming is to perform pair programming, whereas in other software development techniques each developer has an 
own task which needs to be merged in the end. Pair programming is done by two programmers sitting in front of one PC using just one set of 
all required peripherals (screen, keyboard, mouse etc.). Moreover it is usual that the source code and design of the software gets refactored 
and improved during the whole process for the purpose of keeping flexibility high and complexity low.

Compared to other software development techniques there are some major differences: First and foremost there is no specialization of the 
developers on a single task, meaning that an extreme programming programmer has to acquire knowledge and new ways of thinking in all parts 
which are related to software development. Starting with analysing requirements over designing the software architecture to programming, 
testing and maintaining the product after each release.

It should be emphasized that analyzing, designing, as well as the developing of infrastructure and frameworks should not be performed 
up-front. Extreme programming takes the view that those steps are done when needed. This leads to a quicker development start as well 
as more qualified decisions, due to gathered experience while dealing with the project. Thus simplifying the estimate of which details 
deserve more attention than others.

Another advice by Kent Beck in [http://dl.acm.org/citation.cfm?id=318762] is to communicate face-to-face or through efficient tests and 
clear code rather than focussing on writing implementation documentation and wasting time with maintaining those documents.

\subsection{Automotive SPICE}

Automotive SPICE is a standard used to assess development processes of control units in the automotive industry. It is derived from the 
ISO/IEC 15504, which is the general SPICE standard, whose main goal is the assessment of processes in software development. SPICE is an 
abbreviation for \textbf{S}oftware \textbf{P}rocess \textbf{I}mprovement and \textbf{C}apability d\textbf{E}termination, which already 
clarifies the principal aims. Automotive SPICE was developed by  the AUTOSIG - the \textbf{Auto}motive \textbf{S}pecial \textbf{I}nterest 
\textbf{G}roup, to whom many well known manufacturers belong to, such as Audi, BMW, Fiat, Jaguar and a few more.

Generally the Automotive SPICE Process Assessment Model (PAM) can be described as a two-dimensional model consisting of a process dimension 
and a capability dimension. The process dimension defines several process categories, where processes are grouped depending on their type of 
activity. The capability dimension is composed of capability levels, which contain sets of process attributes who provide the measurable 
characteristics of process capability.

The process dimension is described by the Automotive SPICE Process Reference Model (PRM). Thereby 3 process categories are defined: Primary life
cycle processes, organizational life cycle processes and supporting life cycle processes. Each category is furthermore divided into process groups.

The primary life cycle processes category entails an acquisition process group (ACQ), a supply process group (SPL) and an engineering process 
group (ENG). Each group is then described by several processes in detail. ACQ processes are used by the customer as well as the supplier in 
order to acquire a product or a service. SPL processes are meant for the supplier to actually supply a product or a service. ENG processes 
cover the handling of customer’s requirements defined in the ACQ process as well as the specification, implementation and maintaining of the 
software product and its relation to the system.

The supporting life cycle processes category consists only of one support process group (SUP) whose processes can be employed by the other processes at any time.

Lastly the organizational life cycle processes category includes a management process group (MAN), a process improvement process group (PIM) 
and a reuse process group (REU). MAN processes describe practices to manage projects or processes. PIM processes deal with defining, deploying 
and improving processes. REU processes systematically exploit reuse opportunities in organization’s reuse programs.

The capability dimension describes six capability levels as following:

\begin{itemize}
 \item Level 0 - Incomplete process:
 \begin{itemize}
  \item Process is not implemented or fails to achieve its purpose. At this level there is little or no evidence of any systematic achievement of the process purpose.
 \end{itemize}

 \item Level 1 - Performed process:
 \begin{itemize}
  \item The implemented process achieves its process purpose.
 \end{itemize}
 
 \item Level 2 - Managed process:
 \begin{itemize}
  \item The previously described performed process is now implemented in a managed fashion (planned, monitored and adjusted) and its work products are appropriately established, controlled and maintained.
 \end{itemize}
 
 \item Level 3 - Established process:
 \begin{itemize}
  \item The previously described managed process is now implemented using a defined process that is capable of achieving its process outcomes.
 \end{itemize}
 
 \item Level 4 - Predictable process:
 \begin{itemize}
  \item The previously described established process now operates within defined limits to achieve its process outcomes.
 \end{itemize}
 
 \item Level 5 - Optimizing process:
 \begin{itemize}
  \item The previously described predictable process is continuously improved to meet relevant current and projected business goals.
 \end{itemize}
\end{itemize}

\subsection{Clean Code}

Clean code cannot directly be considered as a software development technique by itself. It is rather a common guideline for the whole 
software development process. According to this, a programmer, who is facing the task of developing new software, should prioritize on 
producing clean code from the beginning rather than valuing speed and coding sloppily.

Referring to [CLEAN CODE BUCH] there is no unique definition of clean code. It is more likely that every programmer has his own point of 
view when it comes to this question. Thus there are several definitions which overlap partly as well as other ones which diverge widely. 
An appropriate definition of clean code is coherent code, which is characterized by making sense to a non familiar reader in a short period 
of time. The reader should not be forced to put too much effort into trying to decrypt the intention behind the code. Clean code also offers 
some advantages. Source code which is written clean is rather likely to be more stable. In addition to that maintaining clean code is basically 
much more efficient when it comes to expanding or debugging.

Besides code conventions and design patterns which are depending on an agreement within a software developing team there is a set of rules
which can be followed to enhance the readability of the code according to Robert C. Martin.

% IMAGE

The image above visualizes the clean code concepts by Robert C. Martin based on “Clean Code - A Handbook of Agile Software Craftsmanship” 
which is considered to be among the most important concerning this project. The shown mind map reveals a lot information about the basic 
idea behind clean code according to Robert C. Martin. The following paragraphs are describing each clean code feature a little more detailed 
including some examples to clarify its intention.

Starting with meaningful names, intention-revealing names should have a high priority, as the name of a function, class or variable should 
be self-explaining, thus descriptive comments are considered needless. The names should furthermore be changed, if a better one can be found, 
e.g. a variable should rather be called timeSinceFirstExecution than just single letters or abbreviations as x, y, or tsfe. This also directly 
covers the subitems avoid disinformation, meaningful distinctions, pronounceable and searchable names. An example for bad naming would be the 
usage of uppercase “o” or lowercase “L” due to their similarity with “0” and “1”. Furthermore the author recommends class names consisting of 
nouns and methods using verbs for naming.

It is advised to keep functions as small as possible, meaning that a function consists only of a few lines without being in need of complex 
nested structures, making them more readable and understandable. In addition to that functions should only do one thing, but that they should 
do well and not care for anything else. As highlighted in the earlier paragraph function names should describe the purpose of the function as 
detailed as possible, in such a way that no questions remain open. If several lines of code are repeated over and over again throughout the 
whole program it is better to encapsulate them into a separate function, whereby unnecessary  code duplication is avoided.

As phrased by Robert C. Martin in his book, clean code should preferably contain as few comments as possible because comments are mostly used 
to describe parts which are complicated and unorganized. Further than that comments are considered as a sign for a programmer’s laziness, 
rather placing a comment than investing some time in rethinking the naming of variables or functions. Nevertheless comments which are considered 
good exist as well. Examples of such comments can be looked up in “Clean Code - A Handbook of Agile Software Craftsmanship” as well as examples 
which kind of comments should be avoided.

Executing code formatting is also part of the clean code philosophy, thus enhancing the general readability of the code as well as simplifying 
it for future maintenance. There are some recommendations for both vertical and horizontal formatting, as for instance splitting concepts in 
such a way that closely associated code parts are vertically dense. Same goes for the horizontal formatting, where a certain spacing hints at 
relations and separations. Furthermore indentations should be used to hierarchically separate different scopes.

Due to our extreme programming approach, the chapter “Unit Tests” attracted our attention as the software developing is built upon unit testing 
and test driven development. There is a set of three rules concerning test-driven development besides the already mentioned priority of writing 
and executing tests before code is actually implemented. The first rule says : “You may not write production code until you have written a 
failing unit test”. Rule number two is: “You may not write more of a unit test than is sufficient to fail, and not compiling is failing”. The 
last rule amounts to: “You may not write more production code than is sufficient to pass the currently failing test.”. The author recommends to 
pay attention to maintain the tests clean as well, just as the code which is written afterwards to pass the tests. Clean tests should be designed 
in such a manner that they obey the “F.I.R.S.T.” principle, which is an acronym of five rules:

First of all tests should be fast, meaning they run quickly so they get executed frequently. Moreover test shall be independent from other tests 
as well as repeatable in any environment. Another characteristic is a boolean output, whether a test passes or fails, thus self-validation is 
preferred over confusing log files or other means of output. Lastly tests should be timely, thus writing a test takes place just right before 
writing the real code, due to the probability of developing untestable code otherwise.

At long last classes are treated principally the same way as functions, therefore they also should be as small as possible. As opposed to 
functions the shortness is not measured in lines of code, it is rather depending on the responsibilities of a class. This is covered in the so 
called single responsibility principle. It purports that classes or modules should have only one reason to change. Additionally classes should 
be organized in such a way that they have an obvious structure and is prepared in such a way that code changes do not crash the program or 
induce complicated workarounds.

% ÜBERGANG?!

\subsection{Realization}

The scientific aspect of this bachelor thesis is focused on the combination of agile software development in the automotive context. The 
foundation of this approach builds the Automotive SPICE PAM (PRM) model as well as elements from Kent Beck’s “Extreme Programming Explained”. 
This chapter will describe the design of combining these software development processes, techniques and tools, which restrictions were made 
and which compromises. The following chapter Conclusion is then a subjective summary of our experiences and insights.

The chosen software is in the vicinity of automotive software development but still for users with little to no knowledge about the structure 
and/or the automotive structure itself. Automotive software development falls into the category of safety-critical systems, which have high 
security and low fault tolerance criteria as well as strict and complex testing of its software with severe consequences of failure. However 
safety uncritical systems, like average software, have their focus on usability and visual representation as well as extendability and 
effectiveness. Since this software belongs to two areas of software development,  the conclusion lies near that the development techniques 
from both areas have valid ground for application. Therefore it was necessary to design the development process itself. Starting with the ACQ 
processes from the SPICE development technique set, customer/system requirements were defined.


\begin{tabular}{| c | p{12cm} |}
 \hline
 \textbf{Module} & \textbf{We want an OBD tool...} \\
  \hline
  1 & that is free of charge. \\
  \hline
  2 & whose source code is available. \\
  \hline
  3 & which can read and reset DTCs. \\
  \hline
  4 & with which we can see online sensordata. \\
  \hline
  5 & which is usable through USB interface. \\
  \hline
  6 & whose usability is adapted to the target group. \\
  \hline
  7 & which is easily extendable. \\
  \hline
  8 & which conforms the WWH-OBD and European OBD standards. \\
  \hline
  9 & which is usable with a range of OBD-HW or easily extendable to third party hardware. \\
  \hline
  10 & which can be tested without any hardware. \\
  \hline
\end{tabular}


The next step according to SPICE is to parse those customer requirements to software and hardware requirements. The latter are simple, since 
this project only requires an average ELM327. The software requirements, on the other hand, were designed quite thoroughly.

% LANDSCAPE FUNCTIONAL REQUIREMENTS

The detailed design, which would be the next task, resulted in the first compromis. It seemed smart to move the detailed design of each package 
to right before implementing it. This corresponds to agile software development requirement of doing the design of the task to implement as late 
as possible.

The implementation of the packages was done by using the following agile software development techniques:


\begin{itemize}
 \item Test Driven Development
 \begin{itemize}
  \item trust into the produced code
 \end{itemize}

 \item Pair Programming
 \begin{itemize}
  \item resulting in less time to search bugs
 \end{itemize}
 
 \item Constant Refactoring
 \begin{itemize}
  \item resulting in code resistance and no functionality duplication
 \end{itemize}
\end{itemize}


Since the rough design and thus the order in which the single functionalities have to be implemented was already defined by the SPICE processes,
agile software development for the single packages could easily be applied. Although this approach breaks the premise of agile software 
development to have as little design overhead as possible, but instead doing the design when implementing, it seems to be valid compromise to 
merge the SPICE PRM with the techniques of agile software development. 

Summarized, the approach can be interpreted as the usable process definitions of the SPICE PRM with its advantages, combined with the freedom 
and scalability of agile software development. The difference to the classic SPICE model is including the execution order of certain processes, 
like detailed design. Furthermore the comparison to the requirements is not tested at the completion of the project, but rather defined before 
even beginning programming, through the unit tests. Agile software development differs from its classical approach by taking some flexibility 
through the division into packages at the ACQ phase of the SPICE models. All in all the approach seems valid especially for this kind of 
software and was tested out by implementing code in that certain area as well. A further description of the gained insights can be found in the 
next chapter. 

\section{Conclusion}

The combination of spontaneous agile software development with rigid Automotive SPICE is fusing two contradictory software development areas. 
This results in numerous issues and gathered experience which will be shared in this chapter.

Right after the SPICE PRM planning phase was finished, the actual work on the tools started. The first achievable goal was to establish a 
running communication via the serial interface, more precisely connecting over the USB interface. Due to the early stage of development, more 
accurately the lack of practical experience with the newly created methodology, the implementation took place without real unit tests. 
Furthermore meaningful testing would have been complicated as well, due to the necessity of implementing mocking classes to successfully test 
all parts of the serial communication.

After completing the serial communication the development of the OBD related parts were planned. The longer the focussing on the realization of 
the already planned processes and detailed requirements of the OBD control unit emulation software and the actual OBD tool lasted, many overlaps 
arose. Thus leading to the decision of drifting off from the existing plan and encapsulating the overlapping details in a so called OBD 
middleware. Its purpose was to provide classes and functions which are needed by both softwares.

As time went by we adjusted to the characteristics of agile software development, meaning the writing of unit tests right before actual 
production code was practiced constantly as well as regularly switching the roles as suggested for pair programming. While one wrote an unit 
test which failed after its immediate execution the other one had to observe and point out possible issues. After the unit test was finished, 
the developer of the unit test switched into the observer role and the other one implemented a solution to pass the unit test as well as going 
for the next unit test, alternating the roles constantly.

Over time the quality of the unit tests improved and furthermore the exertion of pair programming led to less debugging and refactoring than 
we were used to compared to previous non agile projects.

Besides the decision of developing a middleware for the OBD software the basic principle of structuring retained as planned from the beginning 
on. Unfortunately cuts in the final softwares were made due to underestimating the time which was consumed by the general implementation and 
refactoring.

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables: 
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End: 
