%%%% Time-stamp: <2012-08-20 17:41:39 vk>

%% example text content
%% scrartcl and scrreprt starts with section, subsection, subsubsection, ...
%% scrbook starts with part (optional), chapter, section, ...
\chapter{Software Development Techniques}
\label{sec:SDT}

When it comes to software engineering one of the most important questions is which software development process 
is the best fit for the particular project requirements. There is a high variety of possible strategies, whereby 
each strategy has its own strengths and weaknesses depending on their field of application. There is no universal 
solution which fits disregarding circumstances. This means some preparation and 
organizational work inside the software team has to be accomplished beforehand. The right software 
has to consider the experience of the software developers, the team size as well as factor in the needs and wishes 
of other stakeholders. It is important to find the most appropriate methodology to satisfy all parties included \cite{BECK}.

Basically software projects can be divided into phases, so called life cycles. The most common life cycles are 
requirements analysis and definition, software design, implementation, verification and maintenance. Taking those 
phases into account a division into two groups evolved: traditional and agile approaches.

Traditional approaches typically execute the phases sequentially, meaning that one phase does not get processed if 
its predecessor has not yet been completed. The waterfall model is considered to be a well-known representative for a traditional approach \cite{WATERFALL},
the basic waterfall model is illustrated in \myfigref{fig:waterfall}.

\myfig{waterfall}%% filename w/o extension in the folder figures
 {width=\textwidth}%% maximum width/height, aspect ratio will be kept
 {Classic Waterfall Development Process \protect{\cite{WATERFALLIMAGE}}}%% caption
 {Figure}%% optional (short) caption for list of figures
 {fig:waterfall}%% label

On the contrary agile approaches are based on iterative and incremental development, which means that the life cycles 
get passed through several times. Thus agile approaches more often result in intermediate software releases which 
encourage adaptations even late in the project’s development phase. Extreme programming is just one of many realisations 
of agile software development methodologies. Since key aspects of its definition are used in the implementation of the OBD 
software its background as well as its approach are covered in this section. 

The following sections layout the reasons for choosing a particular software development technique. 
In addition to that the basics will be explained in particular together with our approach and a final summarization 
containing experiences and knowledge gathered by practicing those methodologies over the course of the bachelor thesis.
The theoretical background is acquired by studying \citeauthor{BECK}'s \citetitle{BECK}\cite{BECK}, \citeauthor{CLEANCODE}'s \citetitle{CLEANCODE}\cite{CLEANCODE} and
\citeauthor{AUTOSPICE}'s \citetitle{AUTOSPICE}\cite{AUTOSPICE}.

\section{Basics}

The motivation to apply the extreme programming methodology is based on the already gathered know-how in this field by attending 
and finishing the course “Softwareentwicklung und Wissensmanagement” in a prior semester. Additionally, taking into consideration 
that the software is designed to be used in an automotive context, the Automotive SPICE\cite{AUTOSPICE} standard, which is derived from the ISO $15504$, 
has to be combined with the test driven development aspect of extreme programming.

Last but not least prioritizing a consistent coding style within the project to keep the source code itself as well as the overall 
structure as clear as possible is intended. Thus simplifying future maintenance and refactoring for programmers who are not implicitly 
the initial developers of the source code. Furthermore this goal is pursued by basically agreeing to an internal coding standard 
based on the book \citetitle{CLEANCODE}\cite{CLEANCODE}.

\subsection{Extreme Programming}
\label{sec:XP}

As mentioned in the previous chapter the extreme programming\cite{BECK} technique falls into the category of agile software development. Generally it is designed 
for small teams to develop software whose requirements change frequently due to their ambiguous definition. Furthermore it is meant 
to be a test driven development approach. In other words a central point of extreme programming is to write unit tests before any ``real'' 
code is written. This promotes the passing of newly written tests as well as already implemented ones. Rather than 
focussing on testing each unit separately, extreme programming also requires to test the whole system, in the best case, several times a day.

Best practice in extreme programming is to perform pair programming, whereas in other software development techniques each developer has an 
own task which needs to be merged in the end. Pair programming is done by two programmers sitting in front of one PC using just one set of 
all required peripherals (screen, keyboard, mouse etc.). Moreover it is usual that the source code and design of the software gets refactored 
and improved during the whole process for the purpose of keeping flexibility high and complexity low.

Compared to other software development techniques there are some major differences: First and foremost there is no specialization of the 
developers on a single task, meaning that an XP programmer has to acquire knowledge and new ways of thinking in all parts 
which are related to software development. Starting with analysing requirements over designing the software architecture to programming, 
testing and maintaining the product after each release.

It should be emphasized that analyzing, designing, as well as the developing of infrastructure and frameworks should not be performed 
up-front. Extreme programming takes the view that those steps are done when needed. This leads to a quicker development start as well 
as more qualified decisions, due to gathered experience while dealing with the project. Thus simplifying the estimate of which details 
deserve more attention than others.

Another advice by \citeauthor{BECK} in \citetitle{BECK}\cite{BECK} is to communicate face-to-face or through efficient tests and 
clear code rather than focussing on writing implementation documentation and wasting time with maintaining those documents.

\subsection{Automotive SPICE}

\citetitle{AUTOSPICE}\cite{AUTOSPICE} is a standard used to assess development processes of control units in the automotive industry. It is derived from the 
ISO/IEC $15504$, which is the general SPICE standard, whose main goal is the assessment of processes in software development. SPICE is an 
abbreviation for \textbf{S}oftware \textbf{P}rocess \textbf{I}mprovement and \textbf{C}apability d\textbf{E}termination, which already 
clarifies the principal aims. Automotive SPICE was developed by the AUTOSIG - the \textbf{Auto}motive \textbf{S}pecial \textbf{I}nterest 
\textbf{G}roup, to whom many well known manufacturers belong to, such as Audi, BMW, Fiat, Jaguar and a few more.

Generally the \citetitle{AUTOSPICE}\cite{AUTOSPICE} Process Assessment Model (PAM) can be described as a two-dimensional model consisting of a process dimension 
and a capability dimension. The process dimension defines several process categories, where processes are grouped depending on their type of 
activity. The capability dimension is composed of capability levels, which contain sets of process attributes who provide the measurable 
characteristics of process capability.

The process dimension is described by the Automotive SPICE Process Reference Model (PRM). Thereby three process categories are defined: Primary life
cycle processes, organizational life cycle processes and supporting life cycle processes. Each category is divided into process groups.

The primary life cycle processes category entails an acquisition process group (ACQ), a supply process group (SPL) and an engineering process 
group (ENG). Each group is then described by several processes in detail. ACQ processes are used by the customer as well as the supplier in 
order to acquire a product or a service. SPL processes are meant for the supplier to actually supply a product or a service. ENG processes 
cover the handling of customer requirements defined in the ACQ process as well as the specification, implementation and maintaining of the 
software product and its relation to the system.

The supporting life cycle processes category consists only of one support process group (SUP) whose processes can be employed by the other processes at any time.

Lastly the organizational life cycle processes category includes a management process group (MAN), a process improvement process group (PIM) 
and a reuse process group (REU). MAN processes describe practices to manage projects or processes. PIM processes deal with defining, deploying 
and improving processes. REU processes systematically exploit opportunities in organization’s reuse programs.

The capability dimension describes six capability levels as following:

\vbox{
\begin{itemize}
 \item Level 0 - Incomplete process:
 \begin{itemize}
  \item Process is not implemented or fails to achieve its purpose. At this level there is little or no evidence of any systematic achievement of the process purpose.
 \end{itemize}

 \item Level 1 - Performed process:
 \begin{itemize}
  \item The implemented process achieves its process purpose.
 \end{itemize}
 
 \item Level 2 - Managed process:
 \begin{itemize}
  \item The previously described performed process is now implemented in a managed fashion (planned, monitored and adjusted) and its work products are appropriately established, controlled and maintained.
 \end{itemize}
 
 \item Level 3 - Established process:
 \begin{itemize}
  \item The previously described managed process is now implemented using a defined process that is capable of achieving its process outcomes.
 \end{itemize}
 
 \item Level 4 - Predictable process:
 \begin{itemize}
  \item The previously described established process now operates within defined limits to achieve its process outcomes.
 \end{itemize}
 
 \item Level 5 - Optimizing process:
 \begin{itemize}
  \item The previously described predictable process is continuously improved to meet relevant current and projected business goals.
 \end{itemize}
\end{itemize}}

\subsection{Clean Code}
\label{sec:CleanCode}

Clean code cannot be considered as a software development technique by itself. It is rather a common guideline for the whole 
software development process. According to this, a programmer who is facing the task of developing new software, should rather prioritize on 
producing clean code from the beginning than valuing speed and coding sloppily.

Referring to \citetitle{CLEANCODE}\cite{CLEANCODE} there is no unique definition of clean code. It is more likely that every programmer has an own point of 
view when it comes to this question. Thus there are several definitions which overlap partly as well as other ones which diverge widely. 
An appropriate definition of clean code is coherent code, which is characterized by making sense to a non familiar reader in a short period 
of time. The reader should not be forced to put too much effort into trying to decrypt the intention behind the code. Clean code also offers 
some advantages. Source code which is written clean is more likely to be more stable. In addition to that maintaining clean code is basically 
much more efficient when it comes to expanding or debugging.

In addition to code conventions and design patterns, which are depending on an agreement within a software developing team, there is a set of rules
which can be followed to enhance code readability according to \citeauthor{CLEANCODE}.

\myfig{mindmap_clean_code}%% filename w/o extension in the folder figures
 {width=\textwidth}%% maximum width/height, aspect ratio will be kept
 {Clean Code Mindmap}%% caption
 {Figure}%% optional (short) caption for list of figures
 {fig:clean_code}%% label

\myfigref{fig:clean_code} visualizes the most important clean code concepts concerning this project. The mind map reveals the basic 
idea behind clean code with high information density. The following paragraphs are describing each clean code feature a little more detailed
including some examples to clarify its intention.

Intention-revealing names are recommended, as the name of a function, class or variable should 
be self-explaining, diminishing the need for descriptive comments. Any chance of improving the naming should be taken. Calling a variable 
timeSinceFirstExecution is more illuminating than single letter variables like x, y or abbreviations such as tsfe. This also directly 
covers the subitems ``avoid disinformation'', ``meaningful distinctions'' and ``pronounceable and searchable names''. In practice the 
usage of uppercase ``o'' or lowercase ``L'' is considered as bad naming due to their similarity with ``$0$'' and ``$1$''.
It is recommended to use nouns for class names and verbs for method naming.

Keeping functions as small as possible, meaning that a function consists only of a few lines without being in need of complex 
nested structures, has the advantage of making them more readable and understandable. Therefore methods should exclusively implement a single functionality, 
neglecting all other circumstances. As highlighted in the earlier paragraph function names should describe the intended purpose of the function as detailed as possible. 
Unnecessary code duplication is avoided by encapsulating recurring code into separate functions.

Due to the nature of comments, describing complicated and unorganized code, it is preferable to have as few comments as possible.
Since comments are considered a sign for programmer laziness, it is better to invest some time into refactoring the naming of variables
and functions rather than placing a comment. Nevertheless good comments exist as well like empty catch-blocks. Further examples can be looked up in 
\citetitle{CLEANCODE}\cite{CLEANCODE}.

Executing code formatting is also part of the clean code philosophy, thus enhancing the general readability of the code as well as simplifying 
it for future maintenance. There are some recommendations for both vertical and horizontal formatting, as for instance splitting concepts in 
such a way that closely associated code parts are vertically dense. Same goes for the horizontal formatting, where a certain spacing hints at 
relations and separations. Furthermore indentations should be used to hierarchically separate different scopes.

The chapter ``Unit Tests'' highly influenced the software development as extreme programming is built upon unit testing 
and test driven development. There is a set of three rules concerning test driven development besides the already mentioned priority of writing 
and executing tests before code is actually implemented:

\begin{enumerate}
 \item ``You may not write production code until you have written a failing unit test.''
 \item ``You may not write more of a unit test than is sufficient to fail, and not compiling is failing.''
 \item ``You may not write more production code than is sufficient to pass the currently failing test.''
\end{enumerate}

It is important to maintain tests as well as the tested code clean. Clean tests should be designed in such a manner that they obey the “F.I.R.S.T.” principle, 
which is an acronym of five rules:

\begin{description}
 \item [F]ast - meaning tests run quickly so they get executed frequently.
 \item [I]ndependent - tests do not influence each other
 \item [R]epeatable - they conclude to the same result in any environment
 \item [S]elf-validating - returning only by a boolean output whether a test passes or fails, no additional log files which lead to confusion
 \item [T]imely - writing a test takes place just right before writing the real code to reduce the risk of untestable code
\end{description}

Concluding classes should be, as do functions, as small as possible. As opposed to functions the shortness is not measured in lines of code, but 
rather in the amount of class responsibilities. This is leads to the so called single responsibility principle which purports that classes or modules 
should have only one reason to change. Additionally they should be prepared for code changes and without obvious structure to avoid complicated workarounds
or program crashes.

\subsection{Realization}

The scientific aspect of this bachelor thesis is focused on the combination of agile software development in the automotive context. The 
foundation of this approach builds the Automotive SPICE PAM (PRM) model as well as elements from \citeauthor{BECK} \citetitle{BECK}. 
This chapter will describe the design of combining these software development processes, techniques and tools, which restrictions  
and compromises are made. The following chapter \nameref{sec:conclusion} is then a subjective summary of experiences and insights.

The chosen software is in the vicinity of automotive software development but still for users with little to no automotive knowledge. 
Automotive software development falls into the category of safety-critical systems, which have high 
security and low fault tolerance criteria as well as strict and complex testing of its software with severe consequences of failure.

However safety uncritical systems, like average software, have their focus on usability and visual representation as well as extendability and 
effectiveness. Since this software belongs to two areas of software development, the conclusion lies near that the development techniques 
from both areas have valid ground for application. Therefore it is necessary to design the development process itself. Starting with the ACQ 
processes from the SPICE development technique set, customer/system requirements are defined.

\begin{tabular}{| c | p{12cm} |}
 \hline
 \textbf{Module} & \textbf{We want an OBD tool...} \\
  \hline
  1 & that is free of charge. \\
  \hline
  2 & whose source code is available. \\
  \hline
  3 & which can read and reset DTCs. \\
  \hline
  4 & with which we can see online sensordata. \\
  \hline
  5 & which is usable through USB interface. \\
  \hline
  6 & whose usability is adapted to the target group. \\
  \hline
  7 & which is easily extendable. \\
  \hline
  8 & which conforms the WWH-OBD and European OBD standards. \\
  \hline
  9 & which is usable with a range of OBD-HW or easily extendable to third party hardware. \\
  \hline
  10 & which can be tested without any hardware. \\
  \hline
\end{tabular}

The next step according to SPICE is to parse those customer requirements to software and hardware requirements. The latter are simple, since 
this project only requires an average ELM$327$. The software requirements, on the other hand, are designed quite thoroughly.

% LANDSCAPE FUNCTIONAL REQUIREMENTS

The detailed design, which is the next task, results in the first compromis. It seems smart to move the detailed design of each package 
to right before implementing it. This corresponds to agile software development requirement of doing the design of the task to implement as late 
as possible.

The implementation of the packages is done by using the following agile software development techniques:

\begin{itemize}
 \item Test Driven Development
 \begin{itemize}
  \item trust into the produced code
 \end{itemize}

 \item Pair Programming
 \begin{itemize}
  \item resulting in less time to search bugs
 \end{itemize}
 
 \item Constant Refactoring
 \begin{itemize}
  \item resulting in code resistance and no functionality duplication
 \end{itemize}
\end{itemize}

Since the rough design and thus the order in which the single functionalities have to be implemented is already defined by the SPICE processes,
agile software development for the single packages can easily be applied. Although this approach breaks the premise of agile software 
development to have as little design overhead as possible, but instead doing the design when implementing, it seems to be a valid compromise to 
merge the SPICE PRM with the techniques of agile software development. 

Summarized, the approach can be interpreted as the usable process definitions of the SPICE PRM with its advantages, combined with the freedom 
and scalability of agile software development. The difference to the classic SPICE model is including the execution order of certain processes, 
like detailed design. Furthermore the comparison to the requirements is not tested at the completion of the project, but rather defined before 
even beginning programming, through the unit tests. Agile software development differs from its classical approach by taking some flexibility 
through the division into packages at the ACQ phase of the SPICE models. All in all the approach seems valid especially for this kind of 
software and is tested out by implementing code in that certain area as well. A further description of the gained insights can be found in the 
\nameref{sec:conclusion} chapter.

%% vim:foldmethod=expr
%% vim:fde=getline(v\:lnum)=~'^%%%%\ .\\+'?'>1'\:'='
%%% Local Variables: 
%%% mode: latex
%%% mode: auto-fill
%%% mode: flyspell
%%% eval: (ispell-change-dictionary "en_US")
%%% TeX-master: "main"
%%% End: 
